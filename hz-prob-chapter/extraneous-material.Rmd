### Issues to be resolved
* estimation of confidence intervals via GAMM ? [ideas here](http://www.fromthebottomoftheheap.net/2014/06/16/simultaneous-confidence-intervals-for-derivatives/)

* how can we simulate from a model developed by `orm()`? See `stats:::simulate.lm` for ideas.

* are we violating any assumptinos of PO logistic regression ? [ideas](http://www.ats.ucla.edu/stat/r/dae/ologit.htm) and [more info](http://www.kenbenoit.net/courses/ME104/ME104_Day8_CatOrd.pdf)

* how can we accomodate the lower effective DF due to massive autocorrelation within "sliced" data? (GEE approach as suggested by Frank Harrell)

* does it make more sense to use the original horizons, and then add thickness weights-- or use the sliced data? I like the slicing approach, but it does give unreasonably small standard error estimates for coefficients.

* use of ordered factors does not change the results of `orm()` and `slab()` barfs with them.

* slice-wise eval of predicted genhz via [Brier Score](http://en.wikipedia.org/wiki/Brier_score#cite_note-Brier-1), or even better: `verification::rps()` for ranked probability scores

* [this method](http://cran.r-project.org/web/packages/ordinal/vignettes/clm_intro.pdf) gives identical models to `orm()`, however the `ordinal` package has some additional features. It is not clear how the "threshold coefficients" could be used:

```
Threshold coefficients:
        Estimate Std. Error z value
A|BA      1.3081     0.1002   13.06
BA|Bt1    2.0080     0.1044   19.24
Bt1|Bt2   6.1038     0.1906   32.03
Bt2|Bt3   9.8494     0.2398   41.07
Bt3|Cr   12.3512     0.2515   49.10
Cr|R     15.1321     0.2652   57.05
```

```{r tbl-generalize-hz-names-tbl, results='asis', echo=FALSE}
# full cross-tab of GHL vs. original designations
cross.tab <- table(loafercreek$genhz, loafercreek$hzname)
# get top-N columns, not including "not-used" row
top.hz <- order(apply(cross.tab[1:length(n), ], 2, sum), decreasing = TRUE)[1:15]
# truncated cross-tabulation
kable(cross.tab[, top.hz], caption = "Generalized Horizon Labels vs. Horizon Designations (truncated counts)")
```

```{r fig-horizonation, fig.width=6, fig.height=5, echo=FALSE, fig.cap='CAPTION ME'}
# check on existing horizonation
barplot(sort(table(loafercreek$hzname), decreasing=TRUE), ylab = "Number of horizons", cex.names=0.5)
```

```{r fig-slicing-results, fig.width=10, fig.height=6, echo=FALSE, fig.cap='CAPTION ME'}
# graphical check: profiles 1:15, top 25 slices
opar <- par()
par(mfrow=c(2,1), mar=c(0,0,0,0))
plot(loafercreek[1:15, 1:25], name='genhz', id.style='side', cex.names=0.9)
plot(s[1:15, 1:25], name='genhz', id.style='side', cex.names=0.9)
par(opar)
```

```{r fig-ml-hz-boundaries, fig.width=10, fig.height=5, echo=FALSE, fig.cap = 'CAPTION ME'}
p.1 <- xyplot(top ~ value | variable, groups=which, data=g, type='l', ylim=c(155, -5), xlim=c(-0.1,1.2), auto.key=list(columns=2, points=FALSE, lines=TRUE), as.table=TRUE, par.settings=list(superpose.line=list(lwd=1, lty=1, col=c('blue','black','red'))), layout=c(8,1), scales=list(y=list(alternating=3, tick.number=10), x=list(alternating=1)), xlab='Probability', ylab='Depth (cm)', strip=strip.custom(bg=grey(0.85)), panel=function(...) {
  panel.abline(h=seq(0, 140, by=10), v=seq(0, 1, by=0.2), col=grey(0.8), lty=3)
	panel.xyplot(...)
})

# add hz-boundaries by slicing vs. PO model
p.1 + latticeExtra::layer(panel.text(x=1, y=a.ml$top[-1], label=expression(symbol("\254")), col='blue', cex=1)) + latticeExtra::layer(panel.text(x=1, y=p.ml$top[-1], label=expression(symbol("\254")), col='red', cex=1))
```

```{r fig-brier-scores, fig.width=10, fig.height=5, echo=FALSE, fig.cap='CAPTION ME'}
# make plot of jittered slice-depths vs. fake probability, colored by genhz label
p.3 <- xyplot(jitter(hzdept) ~ jitter(fake.prob, factor=2), groups=genhz, data=p.s, cex=0.25, pch=15, par.settings=list(superpose.symbol=list(col=alpha(cols, 0.5))))

# combine with model output
p.2 + p.3
```

```{r fig-assumptions-po-model, echo=FALSE, fig.width=5, fig.height=5, fig.cap='CAPTION ME'}
## check assumptions of PO model: pp. 351 in (Harell, 2001)
plot.xmean.ordinaly(genhz ~ hzdept, data=s.sub, subn=FALSE)
```

```{r fig-genhz-depths, fig.width=10, fig.height=5, echo=FALSE, fig.cap='CAPTION ME'}
# plot depth-ranges of generalized horizon slices
ggplot(data = na.omit(horizons(s)[, c('hzdept', 'genhz')])) + 
  geom_boxplot(aes(x = genhz, y = hzdept)) +
  scale_y_reverse(breaks=seq(0, 140, by=10)) +
  labs(x = "Generalized Horizon Label", y = "Generalized Horizon Depth (cm)") +
  theme_bw()
```


## Brier Score Evaluation of ML Horizon Labels

```{r tbl-brier-scores, echo=FALSE}
# larger values -> predictions are less consistently correct
kable(p.bs, digits = 2, caption = "CAPTION ME")
```

### Simulation from GHL Probabilities [this doesn't work, consider leaving out]
```{r simulation-from-model, fig.width=10, fig.height=5}
# simulate GHL at each depth-slice, using probabilities from PO-model
p.sim <- apply(p, 1, function(i) sample(hz.names, size = 10, replace = TRUE, prob = i[hz.names]))

# check... not quite right, too much noise in the predictions
t(p.sim)[1:10, ]
```



### Simultaneous confidence intervals for derivatives of splines in GAMs
not yet ready for prime time...


```{r gamms, eval=FALSE}
## Load mgcv and fit the model
require(mgcv)

# method setup
ctrl <- list(
  niterEM = 0, 
  msVerbose = FALSE, 
  optimMethod="L-BFGS-B"
)

# fitting model
m2 <- gamm(
  formula = value ~ s(top),
  data = subset(g, variable == 'A'), 
  correlation = corARMA(form = ~ 1 | top, p = 2),
  control = ctrl
)

## prediction data
want <- seq(1, nrow(subset(g, variable == 'A')), length.out = 200)
pdat <- with(subset(g, variable == 'A'), data.frame(top = top[want]))

## download the derivatives gist
# tmpf <- tempfile()
# download.file("https://gist.githubusercontent.com/gavinsimpson/ca18c9c789ef5237dbc6/raw/295fc5cf7366c831ab166efaee42093a80622fa8/derivSimulCI.R", tmpf, method = "wget")
# source(tmpf)

library(MASS)

lp <- predict(m2$gam, newdata = pdat, type = "lpmatrix")
coefs <- coef(m2$gam)
vc <- vcov(m2$gam)

set.seed(35)
sim <- mvrnorm(25, mu = coefs, Sigma = vc)

want <- grep("top", colnames(lp))

fits <- lp[, want] %*% t(sim[, want])
dim(fits) ## 25 columns, 1 per simulation, 200 rows, 1 per evaln point

ylims <- range(fits)
plot(value ~ top, data = subset(g, variable == 'A'), pch = 19, ylim = ylims, type = "n")
matlines(pdat$top, fits, col = rgb(0.1, 0.1, 0.1, alpha=0.25), lty = 1)

```

